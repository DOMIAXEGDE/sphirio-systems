# Genesis OS ‚Äî Local HTTPS Dev Setup (PHP + Caddy on Windows)

> Note : Validate Caddy, Run Caddy, Run run-https-dev.ps1, start http://local.dev in PowerShell Terminal as Administrator ...
> see Below :
---

### üîë Quick Start (Admin PowerShell required)

> **Note:** Always run these commands in a **PowerShell Terminal as Administrator** on the first setup. This ensures the `hosts` file and local TLS certificate can be installed cleanly.

1. **Validate your Caddyfile**
   Make sure the config generated by `run-https-dev.ps1` is valid:

   ```powershell
   cd D:\domalecs-os\clix5\OSbench
   caddy validate --config ".\Caddyfile" --adapter caddyfile
   ```

   ‚úÖ Expected: `Valid configuration` (plus optional warnings about formatting)

   *(If you see `unexpected EOF`, open the file and check for missing closing braces `}` ‚Äî or re-run `run-https-dev.ps1` to regenerate it.)*

---

2. **Run Caddy manually (optional check)**
   To confirm Caddy will start cleanly:

   ```powershell
   caddy run --config ".\Caddyfile" --adapter caddyfile
   ```

   ‚úÖ Expected: log lines like

   * `certificate obtained successfully {"identifier":"dev.local","issuer":"local"}`
   * `server running {"name":"srv0","protocols":["h1","h2","h3"]}`

   Stop it again with **Ctrl + C** once you‚Äôve confirmed.

---

3. **Run the PHP + Caddy dev stack automatically**
   Start the full environment (PHP backend + Caddy frontend) with:

   ```powershell
   .\run-https-dev.ps1 -Start -Open -SiteHost dev.local -PhpPort 8000
   ```

   * Adds `dev.local` ‚Üí `127.0.0.1` / `::1` to `hosts` if needed
   * Starts PHP at **[http://127.0.0.1:8000](http://127.0.0.1:8000)**
   * Starts Caddy with HTTPS reverse proxy at **[https://dev.local](https://dev.local)**
   * Opens browser to `https://dev.local/diagnostics.php`

   ‚úÖ Expected logs:

   ```
   Local HTTPS is up. PHP -> http://127.0.0.1:8000 , Caddy -> https://dev.local/
   ```

---

4. **Open Genesis OS in browser**
   Visit:

   ```
   https://dev.local/genesis-os.php
   ```

   * The **Diagnostics** app should show all checks = OK.
   * Genesis OS desktop should boot (login screen, apps sidebar, etc).

---

5. **Stop the dev environment**
   When finished, run:

   ```powershell
   .\run-https-dev.ps1 -Stop
   ```

   ‚úÖ Expected:

   ```
   Stopping Caddy (PID ####)...
   Stopping PHP (PID ####)...
   Done.
   ```

---

üëâ With this workflow, you always:

* Validate ‚Üí Run Caddy once (if debugging)
* Use `run-https-dev.ps1` to handle both PHP and Caddy together
* Access **[https://dev.local](https://dev.local)** for development mode with strict security headers + local certs

---

This guide shows you how to run **Genesis OS** locally over **HTTPS** on Windows using:

* PHP‚Äôs built-in server for the app (HTTP on `127.0.0.1:8000`)
* **Caddy** as a local TLS reverse proxy (`https://dev.local` ‚Üí PHP)

It matches the environment we just verified working (Diagnostics pane: ‚úÖ).

---

## Contents

* [Prerequisites](#prerequisites)
* [Files in this repo](#files-in-this-repo)
* [One-command start/stop](#one-command-startstop)
* [What the script does](#what-the-script-does)
* [Environment variables (security\_bootstrap.php)](#environment-variables-security_bootstrapphp)
* [Verifying it works](#verifying-it-works)
* [Troubleshooting](#troubleshooting)
* [Manual run (without the script)](#manual-run-without-the-script)
* [Clean up](#clean-up)

---

## Prerequisites

> Open **PowerShell** *as Administrator* for the first run (needed to edit `hosts` and allow Caddy to trust a local CA certificate).

* **PHP 8.1+** in `PATH`
  Check: `php -v`
* **Caddy** in `PATH` (via Chocolatey or manual install)
  Install with Chocolatey:

  ```powershell
  choco install caddy
  ```

  Check: `caddy version`
* Windows 10/11 with Edge/Chrome/Firefox (any modern browser)

---

## Files in this repo

```
OSbench/
‚îú‚îÄ run-https-dev.ps1        # helper script to run/stop the dev stack
‚îú‚îÄ Caddyfile                # generated by the script
‚îú‚îÄ https-dev-logs/          # created by the script (PHP/Caddy logs)
‚îú‚îÄ security_bootstrap.php   # app security & headers (dev-friendly)
‚îî‚îÄ genesis-os.php           # your app entry point
```

> You don‚Äôt need to hand-edit `Caddyfile`; the script writes it for you.

---

## One-command start/stop

From the project root (`OSbench`):

### Start (recommended)

```powershell
# First run in an elevated PowerShell window
.\run-https-dev.ps1 -Start -Open -SiteHost dev.local -PhpPort 8000
```

* `-Open` will launch `https://dev.local/diagnostics.php`.
* If the script can‚Äôt edit `hosts` (not elevated), it **falls back to `localhost`** automatically.

### Stop

```powershell
.\run-https-dev.ps1 -Stop
```

### Optional flags

* `-Root "D:\path\to\OSbench"` ‚Äì serve a different project path
* `-NoHeaders` ‚Äì don‚Äôt add COOP/COEP/HSTS in Caddy (rarely needed)
* `-SiteHost localhost` ‚Äì skip hosts edits and use `https://localhost/`

---

## What the script does

1. **Ensures hostname resolution**

   * Adds `dev.local` ‚Üí `127.0.0.1` / `::1` to `C:\Windows\System32\drivers\etc\hosts` (first run, needs admin)
   * If that fails, uses `localhost` as a safe fallback

2. **Generates a `Caddyfile`** that:

   * Serves *static non-PHP* files directly (fast)
   * Proxies `*.php` and non-file routes to PHP (`/index.php`)
   * Adds **security headers** (HSTS, COOP/COEP) unless `-NoHeaders` used

3. **Starts**:

   * PHP: `php -S 127.0.0.1:8000 -t <root>`
   * Caddy: listens on `:443` and reverse-proxies to PHP

4. **Captures logs** in `https-dev-logs\`:

   * `php.out.txt`, `php.err.txt`, `caddy.out.txt`, `caddy.err.txt`

5. **Creates PID files** in `%TEMP%\https-dev-state\` so `-Stop` is clean.

---

## Environment variables (`security_bootstrap.php`)

The bootstrap auto-detects **development** when using local hosts (`*.local`, `localhost`, `127.0.0.1`, `::1`). You can override with env vars:

| Variable                   | Values                       | Default (Dev) | Default (Prod) | Notes                                         |
| -------------------------- | ---------------------------- | ------------: | -------------: | --------------------------------------------- |
| `APP_ENV`                  | `development` / `production` |          auto |           auto | Force if you need                             |
| `APP_DEBUG`                | `1`/`0`                      |           `1` |            `0` | Controls error display                        |
| `APP_HSTS_PRELOAD`         | `1`/`0`                      |           `0` |            `0` | Only for real domains                         |
| `APP_CSP_ALLOW_INLINE_DEV` | `1`/`0`                      |           `1` |            `0` | Allows inline/eval in dev to avoid CSP errors |
| `APP_COEP`                 | `1`/`0`                      |           `0` |            `0` | Enable only if you truly need COEP            |

> In **dev**, we keep CSP strict but permit inline/eval when `APP_CSP_ALLOW_INLINE_DEV=1` to make the UI load without console CSP errors.

---

## Verifying it works

After `-Start`:

1. **Check PHP port**

   ```powershell
   Test-NetConnection 127.0.0.1 -Port 8000
   ```

   `TcpTestSucceeded : True`

2. **Check vhost resolves**

   ```powershell
   ping dev.local
   ```

   Should reply from `::1` or `127.0.0.1`.

3. **Ask Caddy directly**

   ```powershell
   # Use curl.exe, not PowerShell's alias
   curl.exe -k -I https://dev.local/
   ```

   Expect `HTTP/1.1 200 OK` and `Strict-Transport-Security`, `Cross-Origin-Opener-Policy`, etc.

4. **Open the app**

   * `https://dev.local/diagnostics.php` ‚Äì shows flags & environment
   * `https://dev.local/genesis-os.php` ‚Äì Genesis OS boots; Diagnostics app shows all **OK** checks

---

## Troubleshooting

### ‚ÄúCaddy failed to start‚Äù / port 443 issues

* Check something else isn‚Äôt **listening** on 443:

  ```powershell
  netstat -ano | findstr ":443" | findstr LISTENING
  ```

  If a PID shows up, inspect it: `Get-Process -Id <PID>`

### Validate/format the Caddyfile (if you hand-edit)

```powershell
caddy validate --config .\Caddyfile --adapter caddyfile
caddy fmt --overwrite .\Caddyfile
```

### No HTTPS response yet?

* Certificates are auto-managed. On first run, Caddy creates a **local CA** and trusts it in Windows; you‚Äôll see logs like:

  * `certificate obtained successfully {"identifier":"dev.local","issuer":"local"}`
* If you changed the hostname, re-run `-Start` as Admin once to let Caddy trust the new cert.

### PowerShell `curl` errors

Use `curl.exe` (the real curl) not the PS alias:

```powershell
curl.exe -k -I https://dev.local/
```

### Clear stubborn browser state (rare)

If browsers cached HSTS or old state, close them and clear network state/HSTS for the profile. The original `fix-local-ssl.ps1` has a `-PurgeBrowsers` option; or clear per-profile manually.

### Logs

Tail them live:

```powershell
Get-Content .\https-dev-logs\php.err.txt -Wait
Get-Content .\https-dev-logs\caddy.out.txt -Wait
```

---

## Manual run (without the script)

> Only if you prefer doing it by hand.

1. Map host (Admin PowerShell):

   ```powershell
   Add-Content "$env:WINDIR\System32\drivers\etc\hosts" "`n127.0.0.1`tdev.local`n::1`tdev.local"
   ```

2. Start PHP in the project root:

   ```powershell
   php -S 127.0.0.1:8000 -t .
   ```

3. Minimal `Caddyfile`:

   ```caddyfile
   dev.local {
       encode zstd gzip
       root * D:/domalecs-os/clix5/OSbench

       @static {
           file
           not path *.php
       }
       handle @static {
           file_server
       }

       @php_exists {
           path *.php
           file
       }
       handle @php_exists {
           reverse_proxy 127.0.0.1:8000
       }

       @not_static {
           not file
       }
       handle @not_static {
           rewrite * /index.php
           reverse_proxy 127.0.0.1:8000
       }

       header {
           Strict-Transport-Security "max-age=31536000; includeSubDomains"
           Cross-Origin-Opener-Policy same-origin
           Cross-Origin-Embedder-Policy require-corp
       }
   }
   ```

4. Run Caddy:

   ```powershell
   caddy run --config .\Caddyfile --adapter caddyfile
   ```

5. Browse: `https://dev.local/`

Stop: press **Ctrl+C** in the Caddy/Php terminals.

---

## Clean up

* Stop services:

  ```powershell
  .\run-https-dev.ps1 -Stop
  ```
* Remove host mapping (optional):

  * Edit `C:\Windows\System32\drivers\etc\hosts` and remove `dev.local` lines.
* Delete logs if you want: `https-dev-logs\*`

---

## Notes for production (later)

* Use a **real domain** and public TLS (Caddy + Let‚Äôs Encrypt).
* Set `APP_ENV=production`, `APP_DEBUG=0`, remove `APP_CSP_ALLOW_INLINE_DEV`.
* Keep `security_bootstrap.php` ‚Äì it already enforces:

  * **HTTPS redirects**, **HSTS** (optionally `; preload`)
  * **CSP with nonces** (no inline by default)
  * Secure cookies/session settings
  * Hardening headers (X-Frame-Options, Referrer-Policy, etc)

---

Happy hacking! If you hit any rough edges, grab the relevant log from `https-dev-logs\` and re-run with the `-Start` flags you used; the script is idempotent and safe to re-run.

> A file-backed C++23 programming engine with REPL, cross-references, and a pluggable code execution pipeline ‚Äî built for composing entire systems of codebases.

> clix5 ‚Äî A programmable fabric where codebases speak, evolve, and compose into living systems.

# CLI Scripted Kernel ‚Äî Extreme C++23 File-Backed Workflow

A fast, minimal, **file-backed** C++23 CLI for structured ‚Äúbanks‚Äù of registers/addresses, with a **pluggable code-plugin system**. Everything flows through plain **`.txt`** and **`.json`** files so you can version, diff, test, and automate without opaque binaries.

---

## Highlights

* **C++23 single-binary CLI** (`cli-script.exe`)
* **Deterministic file format** for contexts/banks
* **Resolver** supports references across banks/registers
* **Plugins**: language-agnostic, file-based (`run.bat`/`run.sh`)
* **Artifacts**: resolved text + JSON exports under `files/out/`
* **Batteries**: PowerShell build (`build.ps1`), wrapper, smoke tests

---

## Repository Layout

```
.
‚îú‚îÄ build.ps1                    # Build/stage helper (PS 5.1+)
‚îú‚îÄ clix.cmd                     # Wrapper: launches CLI in bin\
‚îú‚îÄ scripted.cpp                 # main (Windows entrypoint uses this)
‚îú‚îÄ scripted_core.hpp            # core data model + parser/resolver
‚îú‚îÄ scripted_kernel.hpp          # code-plugin kernel (no scripted_exec.hpp)
‚îú‚îÄ plugins\                     # source plugins (staged to bin\plugins\)
‚îÇ  ‚îî‚îÄ python\
‚îÇ     ‚îú‚îÄ plugin.json            # { name, entry_win, entry_lin }
‚îÇ     ‚îú‚îÄ run.bat                # Windows entry (args: %1=input.json %2=outdir)
‚îÇ     ‚îî‚îÄ run.sh                 # POSIX entry  (args: $1, $2)
‚îú‚îÄ files\                       # source contexts (staged to bin\files\)
‚îÇ  ‚îî‚îÄ out\                      # resolved + exports (under bin\files\out\)
‚îú‚îÄ bin\                         # build output + staged files/plugins
‚îÇ  ‚îú‚îÄ cli-script.exe
‚îÇ  ‚îú‚îÄ files\                    # working contexts (at runtime)
‚îÇ  ‚îî‚îÄ plugins\                  # working plugins (at runtime)
‚îú‚îÄ smoke.ps1                    # resolver smoke test
‚îî‚îÄ plugin-smoke.ps1             # plugin pipeline smoke test
‚îú‚îÄ parse_text.py                # parse your composed code or composed text file
‚îî‚îÄ compose.py                   # compose a code file automatically (line-by-line)
```

---

## Requirements (Windows)

* **PowerShell 5.1+**
* **MinGW g++ (via Chocolatey)**: `choco install mingw -y`
* Optional: Visual Studio 2022 (if you prefer an IDE) ‚Äî this project also builds fine there as a C++ Console App.

> If PowerShell blocks scripts:
> `Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force`

---

## Build & Run

### Quick build (Release)

```powershell
cd D:\domalecs-os\clix5
.\build.ps1 -Release
```

Artifacts land in `.\bin\` (and the script stages `files\` and `plugins\` into `bin\`).

### Run the CLI

```powershell
# Easiest: use the wrapper so working dir is bin\
clix
# or directly:
cd .\bin
.\cli-script.exe
```

Add the repo root to your **User PATH** to run `clix` from anywhere:

```powershell
$repo = 'D:\domalecs-os\clix5'
$cur  = [Environment]::GetEnvironmentVariable('Path','User')
if ($cur -notlike "*$repo*") {
  [Environment]::SetEnvironmentVariable('Path', $cur.TrimEnd(';') + ';' + $repo, 'User')
}
```

### Build options (PowerShell)

* `.\build.ps1 -Release` ‚Äî optimized (`-O2 -DNDEBUG -s`)
* `.\build.ps1 -Run` ‚Äî build **and** run CLI
* `.\build.ps1 -Clean` ‚Äî remove `bin\`
* `.\build.ps1 -Std c++20` ‚Äî change standard (default: `c++23`)
* `.\build.ps1 -Static:$false` ‚Äî disable static libstdc++/libgcc in Release

> Target: **g++ 13.x** or newer with **-std=c++23** (default).

---

## Concepts

### Context (‚ÄúBank‚Äù)

Each context lives in `files/<ctx>.txt`. The **stem** is the context id (e.g. `x00001`), where `x` is the **prefix**, and the rest is base-N (default base-10) number with fixed widths.

**Bank file format (deterministic)**

```
x00001  (demo context){
01
        0001    print("hello")
02
        0000    x00001.01.0001
}
```

* **Header**: `<ctx>  (<title>){`
* Body is **register blocks**:

  * `01` ‚Äî register id (no indentation)
  * under it, **address lines** (indented by **TAB or SPACE**), `addr` then value
* **Trailer**: `}` on its own line

**Notes**

* UTF-8 BOM is supported (automatically stripped).
* Tabs or spaces are accepted for indentation.
* Widths/base are configurable (see `:set widths`, `:set base`).

### Addressing & Resolution

Resolver expands references in values. Supported forms:

* **`@file(name.txt)`** ‚Äî inline include from `files/name.txt`
* **Prefixed 3-part**: `x<bank>.<reg>.<addr>`
  Example: `x00001.01.0001`
* **Same-bank shorthand**: `r<reg>.<addr>`
  Uses current bank: `r02.0000`
* **Prefixed 2-part** (reg **01** by default): `x<bank>.<addr>`
  Example: `x00001.0001` == `x00001.01.0001`
* **Numeric triad**: `<bank>.<reg>.<addr>`
  Example: `00001.01.0001`

**Order of passes**: `@file` ‚ûú `x.b.r.a` ‚ûú `r.r.a` ‚ûú `x.b.a` ‚ûú `b.r.a`
(Circular references are detected and flagged; missing cells are flagged.)

**Artifacts**

* `files/out/<ctx>.resolved.txt` ‚Äî resolved snapshot (`:resolve`)
* `files/out/<ctx>.json` ‚Äî full structured export (`:export`)

---

## CLI Commands

Type `:help` inside the CLI to see the list. Key commands:

```
:open <ctx>          # open/create context (e.g., x00001 or x00001.txt)
:switch <ctx>        # switch current context
:preload             # load all banks from files/
:ls                  # list loaded contexts
:show                # print current buffer
:ins <addr> <value>  # insert/replace in register 01
:insr <reg> <addr> <value>
:del <addr>          # delete in register 01
:delr <reg> <addr>   # delete in specific register
:w                   # write current buffer to files/<ctx>.txt
:r <path>            # read/merge a raw snippet from file
:resolve             # write files/out/<ctx>.resolved.txt
:export              # write files/out/<ctx>.json
:set prefix <char>   # e.g., x
:set base <n>        # e.g., 10 or 16
:set widths bank=5 addr=4 reg=2
:plugins             # list discovered code plugins
:plugin_run <name> <reg> <addr> [stdin.json|inlineJSON]
:q                   # quit
```

### Examples

```text
:open x00001
:ins 0001 print("hello")
:insr 02 0000 x00001.01.0001
:w
:resolve
:export
```

To import a resolved snapshot back into memory:

```text
:r files/out/x00001.resolved.txt
:show
```

---

## Plugins (file-based, language-agnostic)

**Discovery**
`plugins/*/plugin.json`:

```json
{ "name": "<pluginName>", "entry_win": "run.bat", "entry_lin": "run.sh" }
```

Shown by `:plugins` (prints name and path).

**Invocation**

```
:plugin_run <name> <reg> <addr> [stdin.json | inlineJSON]
```

* Use `{}` for no stdin.
* For inline JSON with spaces, prefer a file: `:plugin_run python 01 0001 files\stdin.json`
* **Don‚Äôt** type the square brackets literally; they mean ‚Äúoptional‚Äù.

**What the Kernel writes per run**
`files/out/plugins/<ctx>/r<reg>a<addr>/<plugin>/`

* `code.txt` ‚Äî resolved cell value
* `input.json` ‚Äî metadata + optional stdin object
* `output.json` ‚Äî **REQUIRED** result (plugin writes this)
* `run.log` / `run.err` ‚Äî captured stdout/stderr
* `run.cmd` ‚Äî Windows breadcrumb (exact command executed)

**Entry script arguments (absolute paths)**

* **Windows (`run.bat`)**: `%1 = input.json`, `%2 = outdir`
* **POSIX (`run.sh`)**: `$1 = input.json`, `$2 = outdir`

**Example Windows plugin (`plugins\python\run.bat`)**

```bat
@echo off
setlocal EnableExtensions EnableDelayedExpansion
set "INPUT=%~1"
set "OUTDIR=%~2"
set "CODE=%OUTDIR%\code.txt"
set "OUT=%OUTDIR%\output.json"

if not exist "%OUTDIR%" mkdir "%OUTDIR%" >nul 2>&1

REM Count lines in code.txt
set "LINES=0"
if exist "%CODE%" for /f %%N in ('^< "%CODE%" find /v /c ""') do set "LINES=%%N"

> "%OUT%" echo { "ok": true, "metrics": { "line_count": !LINES! } }
exit /b 0
```

**`input.json` example**

```json
{
  "bank": "x91001",
  "reg": "01",
  "addr": "0001",
  "title": "My context title",
  "code_file": "C:\\...\\code.txt",
  "stdin": {}
}
```

**Troubleshooting plugins**

* Check `run.err` if `output.json` wasn‚Äôt produced.
* On Windows, run `run.cmd` to reproduce the exact invocation.
* Ensure `plugins/<name>/plugin.json` and entry scripts are **ASCII** (no ‚Äúsmart quotes‚Äù).
* Kernel passes **absolute** paths and correctly quotes all args and redirects.

---

## Smoke Tests

### Resolver smoke

`smoke.ps1` verifies the resolver writes the correct lines into the resolved artifact.

```powershell
.\smoke.ps1
# Prints OK on success
```

### Plugin smoke

`plugin-smoke.ps1` drives the CLI, runs a plugin, and asserts `output.json` exists and parses.

```powershell
.\plugin-smoke.ps1
# Prints OK on success
```

> Both scripts are chatty on failure and dump relevant files.

---

## CI (optional)

Add a minimal GitHub Actions workflow: `.github/workflows/ci.yml`

```yaml
name: ci
on: [push, pull_request]
jobs:
  win-mingw:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - name: Enable PS
        shell: pwsh
        run: Set-ExecutionPolicy Bypass -Scope Process -Force
      - name: Install MinGW
        shell: pwsh
        run: choco install mingw -y
      - name: Build
        shell: pwsh
        run: .\build.ps1 -Release
      - name: Resolver smoke
        shell: pwsh
        run: .\smoke.ps1
      - name: Plugin smoke
        shell: pwsh
        run: .\plugin-smoke.ps1
```

---

## Troubleshooting

**Script blocked**
`Set-ExecutionPolicy RemoteSigned -Scope CurrentUser -Force`

**g++ not found**
`choco install mingw -y`

**`g++: missing filename after -o`**
Your `build.ps1` lost `$SRC`/`$EXE`. Use the known-good compile block (it prints `[vars]` for SRC/EXE).

**Banner shows odd chars**
`chcp 65001 >nul` in your wrapper (`clix.cmd`).

**Parse failed: missing '{' after header**
Ensure the bank file header ends with `{` and a matching `}` at the end; BOMs are stripped automatically.

**`xprint(...)` (stray prefix in resolved text)**
Upgrade resolver order: `x.b.r.a` before numeric `b.r.a`, and guard 2-part matches with `(?!\.)`.

**Plugin errors**

* Check `files/out/plugins/.../<plugin>/run.err`
* Open and run `run.cmd`
* Ensure `plugin.json` points to the right `run.bat`/`run.sh`
* Make sure plugin writes **`output.json`**

---

## Advanced configuration

Inside the CLI:

```
:set prefix x
:set base 10
:set widths bank=5 addr=4 reg=2
```

Internally, exports honor the configured widths/base. Changing them affects parsing/formatting of identities, but file content remains plain text.

---

## Security

Plugins are external processes. Treat them as untrusted:

* Review plugin source before running.
* Keep plugins inside your repo (don‚Äôt point to system-wide scripts).
* CI should run only trusted plugins.

---

## License

Choose one (MIT / Apache-2.0 / BSD-3-Clause). Add `LICENSE` accordingly.

---

## Appendix A ‚Äî Mini Grammar (bank files)

```
<ctx>  (<title>){
<reg>
    <addr>  <value>
    <addr>  <value>
<reg>
    <addr>  <value>
}
```

* `<ctx>`: e.g., `x00001` (prefix + base-N with fixed widths)
* `<reg>`: register id (no indent)
* `<addr>`: address id (indented by TAB or SPACE)
* `<value>`: arbitrary UTF-8 text (may contain references)

**References** inside `<value>`:

* `@file(name.txt)`
* `x<bank>.<reg>.<addr>`
* `r<reg>.<addr>` (same bank)
* `x<bank>.<addr>` (reg 01)
* `<bank>.<reg>.<addr>`

---

Here‚Äôs your full **README.md** for `compose.py`, DOMINIC ‚Äî tailored for clarity, precision, and extensibility. It includes setup, usage, base specification, and examples. You can drop this straight into your repo.

---

# üß† compose.py ‚Äî Register-Address Code Aggregator

`compose.py` is a modular Python script designed to filter and aggregate `code.txt` files from folders named using a register-address pattern (`rXXaYYYY`). It supports flexible filtering by register, address range, and numerical base ‚Äî making it ideal for structured code aggregation workflows.

---

## üìÅ Folder Naming Convention

Each folder must follow this format:

```
rXXaYYYY/
‚îú‚îÄ‚îÄ code.txt
```

- `rXX` ‚Üí Register segment (e.g. `r01`, `rA9`)
- `aYYYY` ‚Üí Address segment (e.g. `a0010`, `aZZ10`)

---

## üöÄ Features

- ‚úÖ Filter by register (e.g. `r01`, `rA9`)
- ‚úÖ Filter by address range per register
- ‚úÖ Specify numerical base for register and address segments
- ‚úÖ Aggregate matching `code.txt` files into a single output
- ‚úÖ CLI interface for automation and scripting

---

## üîß Installation

No external dependencies required.

```bash
git clone <your-repo>
cd <your-repo>
python compose.py --help
```

---

## üß© CLI Usage

```bash
python compose.py \
  --parent <root folder> \
  --cache-dir <output folder> \
  --registers <rXX rYY ...> \
  --range <rXX:start-end rYY:start-end ...> \
  --reg-base <base for rXX> \
  --addr-base <base for aYYYY> \
  --output <filename>
```

---

## üî¢ Base Specification Guide

Use `--reg-base` and `--addr-base` to define how register and address segments are interpreted.

| Base | Characters Used     | Description             |
|------|----------------------|-------------------------|
| 10   | `0-9`                | Decimal                 |
| 16   | `0-9, A-F`           | Hexadecimal             |
| 36   | `0-9, A-Z`           | Alphanumeric (uppercase)|
| 62   | `0-9, A-Z, a-z`      | Full alphanumeric       |

---

## üß™ Examples

### Example 1: Decimal Register, Hex Address

```bash
python compose.py --parent D:\plugins --cache-dir D:\cache \
--registers r01 r02 --range r01:0010-0015 \
--reg-base 10 --addr-base 16
```

### Example 2: Base-36 Register, Base-36 Address

```bash
python compose.py --parent D:\plugins --cache-dir D:\cache \
--registers rA9 rB2 --range rA9:ZZ00-ZZ10 \
--reg-base 36 --addr-base 36
```

### Example 3: Base-62 Address (Full Alphanumeric)

```bash
python compose.py --parent D:\plugins --cache-dir D:\cache \
--registers r01 --range r01:0aZ-1bY \
--reg-base 10 --addr-base 62
```

---

## üìÑ Output

All matching `code.txt` files are aggregated into a single file:

```
<cache-dir>/<output>.txt
```

Default output filename: `composed.txt`

---

## ‚ö†Ô∏è Notes

- Folder names must follow the format `rXXaYYYY`
- Register and address segments are parsed **after** the `r` and `a` prefixes
- Ranges must match the specified base exactly
- Case sensitivity matters in base-62: `a`, `A`, and `1` are distinct

---

## üõ†Ô∏è Extensibility

This script is modular and ready for enhancements:
- Runtime menu support
- Manifest logging
- Interactive folder previews

- Integration with snippet caching or versioning tools

# UPDATE

Perfect. Your current `README.md` already documents the system well, but I‚Äôll enhance it to **capture the full power of clix5** so you‚Äôll always remember what this programming engine is capable of. I‚Äôll merge in the structured guide from your scripted prompt run and highlight its unique strengths.

Here‚Äôs my proposed update (replacement for your current README.md):

---

# CLI Scripted Kernel (clix5) ‚Äî Extreme C++23 File-Backed Programming Engine

A fast, **C++23 single-binary CLI** that treats programming as a structured file-backed workflow.
It manages **banks of registers and addresses** with a deterministic text format, a **cross-reference resolver**, and a **pluggable code execution system**.
All data lives in **plain `.txt` and `.json` files** so you can version, diff, and compose them with zero opacity.

---

## üöÄ Why This Matters

clix5 isn‚Äôt just a toy CLI ‚Äî it‚Äôs a **programming engine**:

* **File-backed persistence** ‚Äî all states are plain-text, reproducible, and auditable.
* **Cross-reference resolution** ‚Äî values can reference any other bank, register, or file.
* **Plugin architecture** ‚Äî execute arbitrary external programs (Python, C++, Bash, batch) as cells.
* **Composable pipelines** ‚Äî aggregate and transform snippets using `compose.py` and `parse_text.py`.
* **Deterministic exports** ‚Äî always reproducible: `.resolved.txt` + `.json` snapshots.
* **UTF-8 / Unicode safe** ‚Äî designed for modern text.
* **Build once, run everywhere** ‚Äî g++23 builds in seconds, PowerShell scripts handle staging.

This makes clix5 a platform for **structured software construction, experimentation, and automation**.

---

## üóÇ Repository Layout

```
.
‚îú‚îÄ build.ps1           # Build/stage helper
‚îú‚îÄ clix.cmd            # Wrapper: launches CLI in bin\
‚îú‚îÄ scripted.cpp        # CLI entrypoint
‚îú‚îÄ scripted_core.hpp   # Data model + parser/resolver
‚îú‚îÄ scripted_kernel.hpp # Plugin execution kernel
‚îú‚îÄ files\              # Source contexts (banks)
‚îÇ  ‚îî‚îÄ out\             # Resolved outputs
‚îú‚îÄ plugins\            # Plugin definitions
‚îÇ  ‚îî‚îÄ python\
‚îÇ     ‚îú‚îÄ plugin.json
‚îÇ     ‚îú‚îÄ run.bat
‚îÇ     ‚îî‚îÄ run.sh
‚îú‚îÄ bin\                # Build output (cli-script.exe + staged files/plugins)
‚îú‚îÄ parse_text.py       # Text transformation engine
‚îî‚îÄ compose.py          # Code aggregator
```

---

## üõ† Core Workflow

### 1. Build

```powershell
cd D:\domalecs-os\clix5
.\build.ps1 -Release
```

### 2. Run CLI

```powershell
clix
:help
```

### 3. Work with Contexts

```text
:open x00001
:ins 0001 print("hello")
:w
:resolve
:export
```

### 4. Run Plugins

```text
:plugins
:plugin_run python 01 0001 {}
```

### 5. Compose & Transform

```bash
python compose.py --parent plugins --cache-dir cache --registers r01 --range r01:0010-0018 --output composed.txt
python parse_text.py --input cache/composed.txt --parser parser.json --output-dir parsed/
```

---

## üîë Key Features Recap

1. **Deterministic file format** ‚Äî bank/register/address layout.
2. **Resolver system** ‚Äî expands references (`@file(...)`, `x00001.01.0001`, etc).
3. **Plugin kernel** ‚Äî language-agnostic execution with strict I/O contracts.
4. **Pipeline scripts** ‚Äî `compose.py` and `parse_text.py` extend functionality.
5. **Human-readable artifacts** ‚Äî everything is `.txt` or `.json`.
6. **CI-ready** ‚Äî smoke tests included.

---

## üåç Philosophy

> ‚ÄúThink first, compute later.‚Äù
> clix5 forces deliberate construction: everything is slow, explicit, file-backed.
> This makes it safe, auditable, and ideal for **serious programming experiments**.
